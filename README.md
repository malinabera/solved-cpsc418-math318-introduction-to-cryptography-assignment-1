Download Link: https://assignmentchef.com/product/solved-cpsc418-math318-introduction-to-cryptography-assignment-1
<br>
<h1><strong style="font-size: 16px;">Problem 1 </strong><span style="font-size: 16px;">— Linear Feedback Shift Register Key Streams (10 marks)</span></h1>

<h1>Written Problems for CPSC 418 and MATH 318</h1>

Stream ciphers such as the one-time pad require a secret key stream of random bits which is bitwise x-or’ed with the plaintext to produce a ciphertext. In this problem, you will cryptanalyze one possible approach for generating such a key stream.

Let <em>m </em>be a positive integer and <em>c</em><sub>0</sub><em>,c</em><sub>1</sub><em>,…,c<sub>m</sub></em><sub>−1 </sub>∈ {0<em>,</em>1} a sequence of <em>m </em>fixed bits. Let <em>z</em><sub>0</sub><em>,z</em><sub>1</sub><em>,…,z<sub>m</sub></em>−<sub>1 </sub>be any sequence of <em>m </em>bits and define <em>z<sub>m</sub>,z<sub>m</sub></em><sub>+1</sub><em>,z<sub>m</sub></em><sub>+1</sub><em>,… </em>via the linear recurrence

<em>z</em><em>n</em>+<em>m </em>≡ <em>c</em><em>m</em>−1<em>z</em><em>n</em>+<em>m</em>−1 + <em>c</em><em>m</em>−2<em>z</em><em>n</em>+<em>m</em>−2 + ··· + <em>c</em>1<em>z</em><em>n</em>+1 + <em>c</em>0<em>z</em><em>n                    </em>(mod 2) <em>,                                                                                      </em>(1)

with the usual arithmetic modulo 2. The fixed bits <em>c</em><sub>0</sub><em>,c</em><sub>1</sub><em>,…c<sub>m</sub></em><sub>−1 </sub>are the <em>coefficients </em>of the linear recurrence (1) and the intial values <em>z</em><sub>0</sub><em>,z</em><sub>1</sub><em>,…,z<sub>m</sub></em><sub>−1 </sub>are its <em>seed</em>. If the seed and the coefficients are appropriately chosen, then (1) generates a sequence of 2<em><sup>m </sup></em>pseudorandom bits<a href="#_ftn1" name="_ftnref1"><sup>[1]</sup></a> (<em>z<sub>i</sub></em>)<em><sub>i</sub></em><sub>≥0 </sub>from a seed of length <em>m</em>. This type of construction is popular since it can be implemented very efficiently in hardware using a <em>linear feedback shift register</em>; see pp. 36-37 of the Stinson-Paterson book.

<ul>

 <li>(2 marks) Let <em>m </em>= 4 and consider the recurrence <em>z<sub>n</sub></em><sub>+4 </sub>≡ <em>z<sub>n</sub></em><sub>+3 </sub>+ <em>z<sub>n </sub></em>(mod 2) with seed (<em>z</em><sub>0</sub><em>,z</em><sub>1</sub><em>,z</em><sub>2</sub><em>,z</em><sub>3</sub>) = (1<em>,</em>0<em>,</em>1<em>,</em>0). Write down the first 19 bits <em>z</em><sub>0</sub><em>,z</em><sub>1</sub><em>,…,z</em><sub>18 </sub>generated by this recurrence and seed.</li>

 <li>(4 marks) A user with knowledge of the coefficients and of any <em>m </em>consecutive bits <em>z<sub>i</sub>,z<sub>i</sub></em><sub>+1</sub><em>,…, z<sub>i</sub></em><sub>+<em>m</em>−1 </sub>(such as the seed, corresponding to the case <em>i </em>= 0) can use (1) to generate the entire sequence of bits (<em>z<sub>n</sub></em>)<em><sub>n</sub></em><sub>≥<em>i </em></sub>starting at <em>z<sub>i</sub></em>. This user is then able to decrypt everything from that point in the plaintext onwards. Explain how an attacker who intercepts a sequence of any 2<em>m </em>consecutive bits <em>z<sub>i</sub>,z<sub>i</sub></em><sub>+1</sub><em>,…,z<sub>i</sub></em><sub>+2<em>m</em>−1 </sub>can potentially obtain the (unknown) coefficients <em>c</em><sub>0</sub><em>,c</em><sub>1</sub><em>,…,c<sub>m</sub></em><sub>−1 </sub>and thus completely break the stream cipher. Your description need not be long, but it should be clear and concise.</li>

 <li>(4 marks) Suppose the sequence (1<em>,</em>1<em>,</em>1<em>,</em>1<em>,</em>0<em>,</em>0<em>,</em>1<em>,</em>1) of 8 consecutive bits was generated using an unknown linear recurrence of the form (1) with <em>m </em>= 4. Use your attack of part (b) to find the coefficients <em>c</em><sub>0</sub><em>,c</em><sub>1</sub><em>,c</em><sub>2</sub><em>,c</em><sub>3 </sub>of this recurrence.</li>

</ul>

(<em>Suggestion: </em>check your answer, i.e. ensure that the coefficients you obtain define a recurrence that produces the second four bits from the first four.)

<strong>Problem 2 </strong>— Password Counts (20 marks plus 5 bonus marks)

In each question below, provide a brief explanation, a formula and the (exact or approximate) numerical value for your answer.

There are 94 <em>printable characters </em>on a standard North American keyboard, comprised of the 26 upper case letters A-Z, the 26 lower case letters a-z, the 10 numerical digits 0-9 and the 32 special characters ‘’”.,;:<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="12332d6c52">[email protected]</a>#$%^&amp;*_-+=(){}[]&lt;&gt;/|. Passwords are strings consisting of printable characters.

<ul>

 <li>(2 marks) What is the total number of passwords of length 8?</li>

 <li>(4 marks) Suppose a user has a password of length 8 whose first four characters are the first four letters of their child’s name (all in either lower or upper case) and the second four characters are the child’s birthday in the format DDMM. Intelligence gathering on your part reveals that the child’s first name starts with ‘L’ and that the child was born in 2008. Making no further assumption about a “reasonable” first name (e.g., for all you know, the kid’s name could be ‘Lxqscdx’), what is the minimal number of candidates that our lazy user could potentially be using as their password?</li>

 <li>(5 marks) To guard against <em>dictionary attacks </em>(where a password cracker checks if a password is a common word or phrase), passwords are typically required to contain at least one numerical digit and at least one special character. What is the total number of passwords of length 8 that satisfy this requirement?</li>

</ul>

(<em>Hint: </em>It is easier to characterize the number of passwords that violate this rule and subtract that count from the total number of 8-character passwords. But be carefully that you don’t subtract some passwords twice.)

<ul>

 <li>(2 marks) What is the percentage of 8-character passwords that satisfy the rule of part (c)?</li>

 <li>(<strong>Bonus Question</strong>, 5 marks) A more stringent complexity rule requires passwords to contain at least one upper case letter, at least one numerical digit and at least one special character. What is the total number of passwords of length 8 that satisfy this rule?</li>

 <li>(3 marks) Assuming that each permissable character in a password is chosen equally likely<a href="#_ftn2" name="_ftnref2"><sup>[2]</sup></a>, what is the entropy of the password space of

  <ul>

   <li>part (a)?</li>

   <li>part (c)?</li>

  </ul></li>

 <li>(4 marks) Suppose we want a password space with entropy 128, assuming that keys are chosen equally likely, i.e. a total of 2<sup>128 </sup>passwords (this number is typical for key space sizes of modern cryptosystems). Assuming no restrictions on the characters appearing in passwords (i.e. the scenario of part (a)), what is the minimum password length that guarantees a password space with entropy 128?</li>

</ul>

<strong>Problem 3 </strong>— Probabilities of Non-Collisions (26 marks)

The cryptographic relevance of this question will become clear when we cover hash functions in class.

In each question below, provide a brief explanation and a formula for your answer. In addition, for parts (d) and (f), provide a numerical value that is an integer.

Let <em>k,n </em>be positive integers with <em>k </em>≤ <em>n</em>. Consider an experiment involving a group of <em>k </em>participants, where we assign each participant a number that is randomly chosen from the set {1<em>,</em>2<em>,…,n</em>} (so all these assignments are independent events). Now pick your favourite number <em>N </em>between 1 and <em>n</em>.

<ul>

 <li>(2 marks) What is the probability that a given participant is assigned your favourite number <em>N</em>?</li>

 <li>(2 marks) What is the probability that a given participant is not assigned the number <em>N</em>? (c) (3 marks) What is the probability that none of the <em>k </em>participants is assigned the number <em>N</em>?</li>

 <li>(4 marks) Intuitively, the more people participate, the likelier the chance that one of them is assigned the number <em>N</em>. In other words, higher values of <em>k </em>decrease the probability that no one gets assigned <em>N</em>.</li>

</ul>

Suppose <em>n </em>= 10. What is the maximal number <em>k </em>of participants in this experiment to ensure at least a 50% chance that none of then is assigned the number <em>N</em>?

<ul>

 <li>(4 marks) Going back to <em>k </em>participants and <em>n </em>numbers, what is the probability that all <em>k </em>participants are assigned different numbers?</li>

 <li>(4 marks) Intuitively, the more people participate, the likelier the chance that two of them are assigned the same number (this is called a <em>collision</em>; hence the title of this problem). In other words, higher values of <em>k </em>decrease the probability that all participants are assigned different numbers.</li>

</ul>

Suppose <em>n </em>= 10. What is the maximal number <em>k </em>of participants in this experiment to ensure at least a 50% chance that they are all assigned different numbers?

<ul>

 <li>(4 marks) Let <em>P </em>be the quantity of part (e). Prove that <em>P </em>≈ exp(−<em>k</em><sup>2</sup><em>/</em>2<em>n</em>) when <em>k </em>is large but is very small compared to <em>n</em>. You may use without proof the following two approximations:

  <ul>

   <li>exp(−<em>x</em>) ≈ 1 − <em>x </em>when <em>x &gt; </em>0 is very small. This comes from the Taylor series</li>

  </ul></li>

</ul>

<em> ,</em>

where the terms from <em>x</em><sup>2</sup><em>/</em>2 onwards are so small that they are negligible compared to 1 − <em>x</em>.

<ul>

 <li><em>k</em>(<em>k </em>− 1) ≈ <em>k</em><sup>2 </sup>(since <em>k </em>≈ <em>k </em>− 1 when <em>k </em>is large).</li>

</ul>

<ul>

 <li>(3 marks) Generalizing part (f) from <em>n </em>= 10 to any <em>n</em>, suppose we want to enlist sufficiently many participants to ensure a roughly 50% chance that they are all assigned different numbers. Use the result of part (g) to prove that the number <em>k </em>of required participants is</li>

</ul>

√

approximately 1<em>.</em>177 <em>n</em>.

(<em>Note: </em>You can solve this question even if you didn’t do parts (f) and (g).)

<strong>Problem 4 </strong>— Equiprobability maximizes entropy for two outcomes, 10 marks

Let <em>X </em>be a random variable consisting of two outcomes <em>X</em><sub>1 </sub>and <em>X</em><sub>2</sub>, both occurring with positive probabilities <em>p</em>(<em>X</em><sub>1</sub>) = <em>p </em>and <em>p</em>(<em>X</em><sub>2</sub>) = 1 − <em>p</em>. The <em>(Shannon) entropy </em>of <em>X </em>is defined to be

<em> .</em>

Note that <em>H</em>(<em>X</em>) <em>&gt; </em>0 since <em>p </em>and 1 − <em>p </em>are both strictly between 0 and 1, so their reciprocals exceed 1, and hence log<sub>2</sub>(1<em>/p</em>) and log<sub>2</sub>(1<em>/</em>(1 − <em>p</em>)) are both positive.

<ul>

 <li>(2 marks) Suppose <em>p</em>(<em>X</em><sub>1</sub>) = 1<em>/</em>8 and <em>p</em>(<em>X</em><sub>2</sub>) = 7<em>/</em> Numerically calculate <em>H</em>(<em>X</em>).</li>

 <li>(6 marks) Prove that if <em>H</em>(<em>X</em>) is maximal, then both outcomes are equally likely. (You may <em>not </em>use Theorems 3.5 and 3.6 of the Stinson-Paterson book.)</li>

</ul>

(<em>Hint: </em>First year calculus: consider <em>H</em>(<em>X</em>) as a function of <em>p </em>and determine for which value of <em>p </em>it takes on its maximum.)

<ul>

 <li>(2 marks) What is the maximal value of <em>H</em>(<em>X</em>)?</li>

</ul>

<h1>Written Problem for MATH 318 only</h1>

<strong>Problem 5 </strong>— Cryptanalysis of a class of linear ciphers, 34 marks)

Let F2 = {0<em>,</em>1} with the usual arithmetic modulo 2. The set consisting of all <em>n</em>-bit vectors with entries 0 or 1 is an <em>n</em>-dimensional vector space over F2 (with the usual canonical basis, for example). Linear algebra works exactly like linear algebra over R<em><sup>n </sup></em>as a vector space over R, except that linear combinations of vectors in have coefficients 0 and 1.

For any <em>n </em>∈ N, let Gl<em><sub>n</sub></em>(F2) denote the set of invertible <em>n </em>× <em>n </em>matrices with zeros and ones as entries. Calculations involving such matrices again work exactly the same as the familiar linear algebra over R you learned in first year, except that arithmetic using real numbers is replaced by arithmetic modulo 2.

Now fix <em>n </em>∈ N and consider the class of linear cryptosystems with), and for all plaintexts <em>m~ </em>(interpreted as <em>n</em>-bit column vectors with entries 0 and 1), encryption under a key matrix <em>K </em>is

<em>E<sub>K</sub></em>(<em>m~</em>) = <em>Km~ .                                                    </em>(2)

Then for all ciphertexts <em>~c, </em>decryption under <em>K </em>is obviously

<em>D<sub>K</sub></em>(<em>~c</em>) = <em>K</em><sup>−1</sup><em>~c .</em>

<ul>

 <li>(5 marks) Prove, by explicitly describing the key matrix <em>K </em>that encrypts an arbitrary plaintext vector <em>m~ </em>to an arbitrary ciphertext vector <em>~c</em>, that a transposition cipher operating on bit strings of length <em>n </em>is a special case of a linear cipher as given in (2), whose key matrices are <em>permutation matrices</em>, i.e. matrices in Gl<em><sub>n</sub></em>(F2) with exactly one one and <em>n </em>− 1 zeros in each row and in each column.</li>

 <li>(4 marks) Explain how a cryptanalyst Eve can mount a chosen plaintext attack on a cipher of the form (2). The goal of this attack is to chose one or more plaintexts, obtain their encryptions under some unknown key matrix <em>K</em>, and derive <em>K</em>. How should Eve choose her plaintexts, and how many does she need to choose in order to be successful?</li>

 <li>(4 marks) Let <em>m~</em><sub>1</sub><em>,m~</em><sub>2</sub><em>,…,m~<sub>i </sub></em>be any collection of <em>i </em>linearly independent vectors in for some <em>i </em>with 1 ≤ <em>i </em>≤ <em>n</em>. Prove that there are 2<em><sup>i </sup></em>vectors such that the vectors <em>m~</em><sub>1</sub><em>,m~</em><sub>2</sub><em>,…,m~<sub>i</sub>,m~<sub>i</sub></em><sub>+1 </sub>are linearly dependent.</li>

 <li>(3 marks) With the notation of part (c), how many vectorsare there so that the vectors <em>m~</em><sub>1</sub><em>,m~</em><sub>2</sub><em>,…,m~<sub>i</sub>,m~<sub>i</sub></em><sub>+1 </sub>are linearly independent?</li>

 <li>(5 marks) Prove that the number of sets consisting of <em>n </em>linearly independent vectors in is</li>

</ul>

<em> .</em>

<ul>

 <li>(5 marks) Prove that the probability that any set of <em>n </em>vectors in is linearly independent is</li>

</ul>

<em> .</em>

<ul>

 <li>(3 marks) Suppose <em>n </em>= 4. What is the probability that any set of 4 vectors in is linearly dependent?</li>

 <li>(5 marks) Part (b) considered a <em>chosen </em>plaintext attack, whereas we now consider the scenario of mounting a <em>known </em>plaintext attack on a linear cipher as given in (2). Given a set of known plaintext/ciphertext pairs where all the plaintexts were encrypted to their respective corresponding ciphertexts using the same unknown key matrix <em>K</em>, the goal of this attack is to find <em>K</em>.</li>

</ul>

Assume that linear dependence of any collection of <em>n </em>plaintexts inrepresents independent events, i.e. if <em>p </em>is the probability that any <em>n </em>plaintexts are linearly dependent, then <em>p</em><sup>2 </sup>is the probability that any two collections of <em>n </em>plaintexts are linearly dependent. Explain how Eve can use multiple attempts at a known plaintext attack to find a key matrix. What is the minimal number of attempts to guarantee Eve a chance of success of least 99 percent when <em>n </em>= 4?

<h1>Programming Problem for CPSC 418 only</h1>

<strong>Problem 6 </strong>— Password attack on an authenticated encryption scheme (34 marks)

<strong>Overview. </strong>Suppose Bob has designed his own authenticated encryption scheme, using the hash-then-encrypt paradigm, with AES-128 in CBC mode for encryption, and SHA1 for the key derivation function and message hash tag. On input the name of a plaintext file and a password <em>p</em>, Bob’s program does the following:

<ul>

 <li>Converts the plaintext file to a byte array <em>B</em>.</li>

 <li>Computes a hash tag <em>t </em>on the plaintext by applying SHA1 to the byte array <em>B</em>, then appends <em>t </em>to <em>B </em>to obtain an extended byte array <em>B</em><sup>0 </sup>= <em>B</em>||<em>t </em>(here, as always, “||” denotes concatenation).</li>

 <li>Derives an encryption key by applying SHA1 to the password <em>p </em>and truncating the result to the appropriate length for use in AES-128.</li>

 <li>Generates a random 16-byte initial value IV (for use in CBC mode) and writes it to a file <em>F</em>.</li>

 <li>Pads the extended byte array <em>B</em><sup>0 </sup>using the PKCS7 format if necessary, then encrypts the padded array with AES-128-CBC and appends the resulting ciphertext to the file <em>F</em>.</li>

</ul>

Out of laziness, Bob is known to use <em>strings </em>of the form YYYYMMDD, which mark certain dates from his life, as his passwords. Bob was born in the year 1984, and always includes the string FOXHOUND in his communications.

<strong>Problem. </strong>Your task is to create a Python 3 program that takes as input a file produced by Bob’s hash-then-encrypt routine and performs the following tasks:

<ul>

 <li>Determines the password used to derive the encryption key and prints it out.</li>

 <li>Decrypts the ciphertext using this key.</li>

 <li>Checks the resulting plaintext for the phrase CODE-RED. If present, the program replaces this phrase with the phrase CODE-BLUE and writes the modified plaintext to a new file. If not present, the plaintext is left unchanged.</li>

 <li>In the event that the plaintext was modified as specified in step (c), your program now does the following:

  <ol>

   <li>Computes a new hash tag on the modified plaintext.</li>

   <li>Generate a new 16-byte IV.</li>

  </ol></li>

</ul>

<ul>

 <li>Re-encrypt the modified plaintext plus new tag using the same password and exactly the same process as Bob’s hash-then-encrypt program.</li>

</ul>

<ol>

 <li>Writes the result to a new file. Be aware that modified files may require padding, for which you should use PKCS7 as the padding format. Also recall that AES-128-CBC has a block size of 16 bytes.</li>

</ol>

<strong>Specifications. </strong>Design and implement your solution as two Python 3 programs entitled modifyFile and encryptFile. The first program should perform steps (a)-(c) above, and be invoked by the command

python3 modifyFile [ciphertext-filename]

where the input file ciphertext-filename is the file produced by Bob’s hash-then-encrypt routine. The second program should perform step (d) above, and be invoked by the command

python3 encryptFile [plaintext-filename] [tampered-filename] [password]

where the input file plaintext-filename contains the (potentially modified) plaintext produced in steps (b) and (c) above, the output tampered-filename is the file created in step (d) iv. above, and password is the password found in step (a).

Programs that do not comply with these specifications will be penalized or not marked at all. Use the latest version of the Python <em>cryptography </em>library found at

https://cryptography.io/en/latest/

This link can also be found on the “references” page of our course website. Use this library for all the required cryptographic primitives, including the PKCS7 padding module.

The cryptography library has its own interface to which you are expected to adhere. You <strong>must </strong>make use of the <em>hazardous materials layer</em>, <strong>not </strong>the <em>recipes layer</em>. Make sure to use good coding practices.

You may use whatever development platform you like. The TAs will test your programs using the latest version of python3 installed on the CPSC Linux servers. The testing inputs will be Bob’s encryptions of at least two different plaintext files which may or may not contain the phrase CODE-RED.

You may assume all plaintext files are text files of at most 1 MB in size. All byte encoding is done using UTF-8.

<strong>Submission. </strong>Submit a description of your implementation in a separate README file in text format. <strong>Do </strong><em>not </em><strong>include the written portion of the programming problem in the PDF file containing your solutions to the written problems. </strong>Your description must include the following:

<ul>

 <li>A list of the files you have submitted that pertain to the problem, and a short description of each file.</li>

 <li>A list of what is implemented in the event that you are submitting a partial solution, or a statement that the problem is solved in full.</li>

 <li>A list of what is not implemented in the event that you are submitting a partial solution.</li>

 <li>A list of known bugs, or a statement that there are no known bugs.</li>

 <li>Any other answers to questions specified in the problem.</li>

</ul>

<h1>Bonus Problem for CPSC 418 and MATH 318</h1>

<strong>Problem 7 </strong>— Mixed Vigen`ere cipher cryptanalysis, 10 marks

<em>This is a hard problem. </em>Mixed Vigen`ere cipher cryptanalysis is far more difficult than ordinary Vigen`ere cipher cryptanalysis as illustrated in some of our handouts.

Decrypt the following ciphertext that was encrypted using a <em>mixed </em>Vigen`ere cipher. Show all your work; this includes source code if you used programming. Answers without satisfactory explanation and documentation of how they were obtained will receive <em>no </em>credit. Neither will answers obtained by simply running mixed Vigen`ere decryption from an online crypto applet website on the ciphertext.

A text file containing the ciphertext can be downloaded from the “assignments” page.

<em>Hint: </em>The key word has length 6.

UNFDN KEPBX PXNMF IOWHM IDNHH ETEJV UNYIV OEXUF OCWVM DZRTB RETEV

XYENE GPFOV QTLFR CVPBV UNQGH YMQFE KUIOV PKYUV FTXOE VXMNA JMTCW

OEZRW BXLQV UNFAT OYNOL VXNQQ DZRXB AQVFG NJIPC ZHFUN FGHQH FXGFA

SUVPH ODZRY BFFMH CEOOK WEFII ZWBLA JTREN BHSRC XDZJF CJBVU DVGOI

UZQBB MURNC GONEU NFXVX WXEFZ IEJYI USVRQ KOWIQ RIBYN GNDZR DGOLV

QPGVX VWEWB MUREQ USVNW BYMVC VLGMO VVCMF ERNDJ VMTCV AEOAV CULNW

ZVFFJ FCJOL QVPHM JQTHX EOVCD KQFOC XGPXW QVWOL VKCKT MOPUG XVZXZ

CFDNY RXAOM TUGKE CFOGQ TNFEQ QKMWE HOKJO RLJVB QVGUD CFMVV HCFYD

AZOPG KYFUC WWASU DVBER ZOUKI IQCGC AVQFZ NFMJZ HFJVM TCHTD PSEHN

IUCNR QQVFZ GYVCH PWBVW RWFII JHPKB OUECX NZMVC BJVXV PHODZ RYBJJ

WOENB HLIUB FHJWE XFDBZ NGOLV QUGEI QVPHQ HJXSK ELCHD HJHVF GQUDV

QNGQV VVPQN XVDRP BXBXT JOESR NRULC FYCAZ MTUGB CVFYK IMBZN GOLVQ

GJFFM TWXEL CHGQU DVQGJ JXZWE GYDZX UXJKZ VWBJF OFCJJ XLXUA IIUVP

KGMJH UGGLV QNHWI OHXHR QMWZG YVVQC EAOMO EMOEZ RNLBD ZRNGQ FPDUN

FAUHC KQFOC PKBOU VPKQI GVDGY VCFYN FOIWD EBVKH CFAZM YVBNM BVJGA

HQHUN FJCQG FYFKH VLOLV QTCJV XHHXX IJRGV BVMOE MOLJW HMIDZ RSKBQ

VCNGA JBXEJ RONWA KEFPD CDUEW VPKXI VUTXH DNKEI PUCCD GYVCF YHMMX

TUBBM OZCMB VMWRH MSQHU NFAFR NKNFY OEMOL VONPB AOWNF IDZQV RHLQD

WXEEW PNKFV WOCVE XQFZV JDMDC YJSPX YKUFB SCFOL VSPHE XVREX AXCPE

CAJWO YNOMO PXROF PDUNF EMTCB OOQJC VFOBX BGQKM TCBVD MRZBA FUHCK

NIUVV IFKNO EMJVM TCGOL VQZQY IIVTG QFOCU NFRNE CXJVM TCYJS PXYKU

DZRQE BXBRZ MBPVC WFOLV EJQOL FXNDF AVHWX EQVUU FIICQ MNJSU QCXRS

NHCLV OMTCB QEJVP FIIWO CVEXX XIKXF KVVBA SPOEM IMPDG HQHMT TALKJ

WIKUE WWBJG EJRGF OLVQV HEHFO EJMIU VVHOO QNAHQ HEOBV BKVHX KRFTR

BKUXI WDWAV

<a href="#_ftnref1" name="_ftn1">[1]</a>     <em>m</em>

Since there are only 2 − 1 distinct non-zero bit patterns of length <em>m</em>, there must be repetition after at most 2<em><sup>m</sup></em>− 1 bits. So in practice, <em>m </em>must be large.

<a href="#_ftnref2" name="_ftn2">[2]</a> This assumption may be appropriate for passwords chosen by computer systems with good random number generators, but it is utterly false for passwords chosen by humans. So in practice, the minimum password length computed in part (g) is a significant underestimate.